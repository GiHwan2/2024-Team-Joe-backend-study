# item 26

## 로 타입은 사용하지 말라 

### 로 타입 

```
로 타입: 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
로 타입의 위험성: 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다. 
로 타입의 필요성: 제네릭을 받아 들이기까지 10년이 걸린 탓에 제네릭 없이 짠 코드를 수용하면서 제네릭을 사용하는 새로운 코드와 맞물려 돌아가게 해야 했기 때문.
로 타입의 예외: 1. class 리터럴에는 로 타입을 써야 한다. 2. 제네릭 타입에 instanceof를 사용할 때. 
```


# item 27 

## 비검사 경고를 제거하라 

### 비검사 경고를 제거하는 법 

```
1. 할 수 있는 한 모든 비검사 경고를 제거하라. 
2. 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 애너테이션을 달아 경고를 숨기자. 
3. @SuppressWarnings 애너테이션은 항상 가능한 한 좁은 범위에 적용하자. 
4. @SuppressWarnings("unchecked") 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석드로 남겨야 한다. 
```


# item 28 

## 배열보다는 리스트를 사용하라 

### 배열 vs 제네릭 타입 

```
1. 배열은 공변이다 - 함께 변한다. 반면, 제네릭은 불공변이다. 
2. 배열은 실체화된다. 반면, 제네릭은 타입 정보가 런타임에는 소거된다. 

따라서, 둘을 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자. 
```


# item 29 

## 이왕이면 제네릭 타입으로 만들라 

### 일반 클래스를 제네릭 클래스로 만들기 

```
1. 클래스 선언에 타입 매개변수를 추가하는 일이다. 
2. 다음, 코드에 쓰인 Object를 적절한 타입 매개변수로 바꾸고 컴파일해보자. 
3. E처럼 실체화 불가 타입으로는 배열을 만들 수 없다. 따라서 1. 제네릭 배열 생성을 금지하는 제약을 대놓고 우회 or 2. elements 필드의 타입을 E[]에서 Object[]로 바꾸기. 
```


# item 30 

## 이왕이면 제네릭 메서드로 만들라 

### 제네릭 메서드 

```
1. 타입 안전하게 만들기 - 메서드 선언에서의 세 집합의 원소 타입을 타입 매개변수로 명시하고, 메서드 안에서도 이 타입 매개변수만 사용하게 수정하면 된다. 
2. 불변 객체를 여러 타입으로 활용 - 제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있음. 
3. 항등함수를 담은 클래스 만들기 - 제네릭 싱글턴 하나를 사용한 소거 방식 사용 
4. 재귀적 타입 한정 - 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰기. 
```


# item 31 

## 한정적 와일드카드를 사용해 API 유연성을 높이라 

### 한정적 와일드카드 

```
유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라. 
규칙: 펙스 (PECS): producer-extends, consumer-super 
뜻: 매개변수화 타입 T가 생산자라면 <? extends T>를 사용하고, 소비자라면 <? super T>를 사용하라. 

타입 매개변수와 와일드카드에는 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느 것을 사용해야할까? 
규칙: 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라. 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 된다. 
```


# item 32 

## 제네릭과 가변인수를 함께 쓸 때는 신중하라 

### 제네릭 varargs 매개변수 

```
제네릭 배열을 직접 생성하는 건 허용하지 않으면서 제네릭 varargs 매개변수를 받는 메서드를 선언할 수 있게 한 이유는? 
답: 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 메서드가 실무에서 매우 유용하기 때문. 

제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다. 
예외 2가지: 1. @SafeVarargs로 애노테이트된 또 다른 varargs 메서드에 넘기는 것은 안전하다. 2. 그저 이 배열 내용의 일부 함수를 호출만 하는 일반 메서드에 넘기는 것도 안전하다. 
```


# item 33 

## 타입 안전 이종 컨테이너를 고려하라 

### 타입 안전 이종 컨테이너 

```
컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 제약 없는 타입 안전 이종 컨테이너를 만들 수 있다. 
```




